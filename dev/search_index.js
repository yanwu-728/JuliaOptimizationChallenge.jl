var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = JuliaOptimizationChallenge","category":"page"},{"location":"#JuliaOptimizationChallenge","page":"Home","title":"JuliaOptimizationChallenge","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for JuliaOptimizationChallenge.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [JuliaOptimizationChallenge]","category":"page"},{"location":"#JuliaOptimizationChallenge.Problem","page":"Home","title":"JuliaOptimizationChallenge.Problem","text":"Store a problem which represents a city using a matrix and other parameters\n\nFields\n\n- total_duration::Int: total time allotted for the car itineraries (in seconds)\n- nb_cars::Int: number of cars in the fleet\n- starting_junction::Int: junction at which all the cars are located initially\n- junctions::Vector{Junction}: list of junctions\n- adjacency::Vector{Vector{Street}}: list where ith entry is all the streets that you can travel through from ith junction\n\n\n\n\n\n","category":"type"},{"location":"#JuliaOptimizationChallenge.Problem-Tuple{HashCode2014.City}","page":"Home","title":"JuliaOptimizationChallenge.Problem","text":"Creates a Problem instance using a HashCode2014.jl City object\n\n\n\n\n\n","category":"method"},{"location":"#JuliaOptimizationChallenge.compute_upper_bound-Tuple{Any}","page":"Home","title":"JuliaOptimizationChallenge.compute_upper_bound","text":"Calculate an upper bound on the number of meters that can be covered using a HashCode2014.jl City instance\n\n\n\n\n\n","category":"method"},{"location":"#JuliaOptimizationChallenge.find_lookforward_paths_parallel-NTuple{4, Any}","page":"Home","title":"JuliaOptimizationChallenge.find_lookforward_paths_parallel","text":"Helper function that finds all possible paths at certain junction, with the current visited street.\n\nOutput\n\n- the optimal path at N steps\n\n\n\n\n\n","category":"method"},{"location":"#JuliaOptimizationChallenge.solver_parallel_lookforward-Tuple{Any}","page":"Home","title":"JuliaOptimizationChallenge.solver_parallel_lookforward","text":"Find a possible solution of itineraries for each car, given a problem instance\n\nOutput\n\n- a set of itineraries for each of the cars\n\n\n\n\n\n","category":"method"},{"location":"newindex/#JuliaOptimizationChallenge","page":"Explanation","title":"JuliaOptimizationChallenge","text":"","category":"section"},{"location":"newindex/#Data-Structure","page":"Explanation","title":"Data Structure","text":"","category":"section"},{"location":"newindex/","page":"Explanation","title":"Explanation","text":"We modified the original data structure from HashCode2014.jl to store additional information. In particular, the streets now could be stored in an adjacency list, which allows one to easily have access to all the outgoing streets given a junction. This will be particularly useful if we would like to make a comparision among different options a car could take given that the last junction the car is at.","category":"page"},{"location":"newindex/#Solver-Algorithm","page":"Explanation","title":"Solver Algorithm","text":"","category":"section"},{"location":"newindex/","page":"Explanation","title":"Explanation","text":"The algorithm we used is...","category":"page"},{"location":"newindex/#Efficiency","page":"Explanation","title":"Efficiency","text":"","category":"section"},{"location":"newindex/","page":"Explanation","title":"Explanation","text":"Assign a type for any collection of elements that we created\nUsed push! and append! to add to vectors without creating a new vector\nKeep track of the junction visited using a set so that we can check if a junction has been visited in constant time","category":"page"},{"location":"newindex/#Upper-Bound","page":"Explanation","title":"Upper Bound","text":"","category":"section"},{"location":"newindex/#Description","page":"Explanation","title":"Description","text":"","category":"section"},{"location":"newindex/","page":"Explanation","title":"Explanation","text":"We computed our upper bound by adding up the distances of all of the streets in order from fastest to slowest until we reached the total duration times the number of cars. Note that when we reach a point that we can't include an entire street without going over the time limit, we take whatever fraction of the street we can take.","category":"page"},{"location":"newindex/#Proof","page":"Explanation","title":"Proof","text":"","category":"section"},{"location":"newindex/","page":"Explanation","title":"Explanation","text":"Let OPT be some optimal solution for the upper bound problem. Assume for contradiction that OPT differs from our solution in portion of at least one street. In this case, there is some fraction of some street, s* , that is in OPT that was not included in our upper bound algorithm. Since we include streets in order of decreasing speed, s* must be no faster than any street we included in the upper bound. Let the chunk of s* that we don't include have distance d* and duration t* . Notice that for any chunk of t* time, the streets that are included in our upper bound will all have contributed a distance of at least d* because they were all at least as fast as s* . Therefore, if we replace any chunk of duration t* in our upper bound with a chunk from s* of equal duration, the total distance covered will either stay the same or decrease. Notice that if the distance stays the same, then we can repeat this process until our upper bound was transformed into OPT with the total distance. This would imply that our upper bound was optimal to begin with. Otherwise, if the distance decreases when we swap in s* , this would imply that OPT was not optimal because our upper bound was better which is a contradiction. Since our assumption was that OPT differs from our upper bound, this contradiction would imply that OPT is the same as our upper bound. Therefore, there must exist no way to pick streets such that the sum of the durations is at most total_duration and sum of the distance is larger than our upper bound.","category":"page"},{"location":"newindex/#Runtime","page":"Explanation","title":"Runtime","text":"","category":"section"},{"location":"newindex/","page":"Explanation","title":"Explanation","text":"The algorithm takes O(nlogn) time where n is the number of streets. Sorting the streets by the speed takes O(nlogn) time, and the greedy algorithm of traversing each street and take the distance takes O(n) time. ","category":"page"},{"location":"newindex/#Efficiency-2","page":"Explanation","title":"Efficiency","text":"","category":"section"},{"location":"newindex/","page":"Explanation","title":"Explanation","text":"Used sort! to sort in place instead of creating a new vector","category":"page"}]
}
